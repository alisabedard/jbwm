/*
 * arwm - Restructuring, optimization, and feature fork
 *        Copyright 2007-2012, Jeffrey E. Bedard <jefbed@gmail.com>
 * evilwm - Minimalist Window Manager for X Copyright (C) 1999-2006 Ciaran
 * Anscomb <arwm@6809.org.uk> see README for license and other details.
 */

#include <signal.h>
#include <X11/cursorfont.h>
#include <unistd.h>
#include "arwm.h"

/* Main application data structure.  */
ARWMEnvironment arwm;

static void
initialize_ARWMEnvironment_keymasks(void)
{
	arwm.keymasks.numlock = LOCK_MASK;
	arwm.keymasks.grab = GRAB_MASK;
	arwm.keymasks.mod = MOD_MASK;
}

static void
initialize_ARWMEnvironment(void)
{
	arwm.initialising = None;
	initialize_ARWMEnvironment_keymasks();
	arwm.titlebar.initialized = False;
}

/* These are difficult to consolidate in
   ARWMEnvironment structure, as memory would
   have to be manually allocated for each.  */
/* Things that affect user interaction */
GlobalOptions opt = 
{
	DEF_FONT,
	{DEF_FG, DEF_BG, DEF_FC},
	DEF_TERM
};

Application *head_app = NULL;

/* Client tracking information */
Client *head_client = NULL;
Client *current = NULL;

#ifdef USE_ARGV
static void
process_app_class_options(const char *name)
{
	char *tmp;
	Application * new = calloc(1, sizeof(Application));

	{
if (!((tmp = strchr(name, '/'))))
goto l_1;

	{
		*(tmp++) = 0;
		{
if (!(strlen(tmp) > 0))
goto l_2;

		{
			new->res_class = malloc(strlen(tmp) + 1);
			strcpy(new->res_class, tmp);
		}l_2:;
}
}l_1:;
}
{
		const size_t namelen = strlen(name);

		{
if (!(namelen > 0))
goto l_3;

		{
			new->res_name = malloc(namelen + 1);
			strcpy(new->res_name, name);
		}l_3:;
}
}
	new->next = head_app;
	head_app = new;
}

/* Used for overriding the default WM modifiers */
static unsigned int
parse_modifiers(char *s)
{
	static struct
	{
		const char *name;
		unsigned int mask;
	} modifiers[9] = { { "shift", ShiftMask}, { "lock", LockMask}, 
		{ "control", ControlMask}, { "mod", Mod1Mask}, 
		{ "mod1", Mod1Mask}, { "mod2", Mod2Mask}, { "mod3", Mod3Mask},
		{ "mod4", Mod4Mask}, { "mod5", Mod5Mask}};
	const char * delim = ",+";
	char *tmp;
	unsigned int ret = 0;
	{
tmp=strtok(s, delim);l_4:
if (!( tmp))
goto l_6;
goto l_7;
l_5: tmp=strtok(NULL, delim);
goto l_4;
l_7:

	{
		ubyte i=0;

		{
l_8:
if (!(i++ < 8))
goto l_9;

			{
if (!(!strcmp(modifiers[i].name, tmp)))
goto l_10;

				ret |= modifiers[i].mask;l_10:;
}
goto l_8;
l_9:;
}
}goto l_5;
l_6:;
}


	return ret;
}

static void
parse_geometry(const char * arg)
{
	XRectangle g;

	{
if (!(!head_app))
goto l_11;

		return;l_11:;
}
head_app->geometry_mask = XParseGeometry(arg, 
		(int *)&g.x, (int *)&g.y, 
		(unsigned int *)&g.width, 
		(unsigned int *)&g.height);
	head_app->geometry = g;
}

static void
parse_command_line_args(int argc, char **argv)
{
	int i;

	{
i = 1;l_12:
if (!( i < argc))
goto l_14;
goto l_15;
l_13: i++;
goto l_12;
l_15:

	{
		{
if (!(argv[i][0] != '-'))
goto l_16;

			goto l_13;l_16:;
}
switch (argv[i][1])
		{
#define ARG argv[++i]
#define SETARG(arg) arg = ARG
#define SETNARG(arg) arg = atoi(ARG)
		case 'd':
			setenv("DISPLAY", ARG, 1);
			break;
		case 'F':
			SETARG(opt.font);
			break;
		case 'f':
			SETARG(opt.color.fg);
			break;
		case 'b':
			SETARG(opt.color.bg);
			break;
		case 'c':
			SETARG(opt.color.fc);
			break;
		case 'T':
			SETARG(opt.term);
			break;
		case 'A':
			process_app_class_options(ARG);
			break;
		case 'g':
			parse_geometry(ARG);
			break;
		case '1':
			arwm.keymasks.grab = parse_modifiers(ARG);
			break;
		case '2':
			arwm.keymasks.mod = parse_modifiers(ARG);
			break;
		case 'V':
			LOG_INFO("arwm version " VERSION "\n");
			exit(0);
		default:
			fprintf(stderr,
				"arwm -[d:F:f:b:v:T:w:s:A:g:Vv:S1:2:]\n");
			exit(0);
		}
	}goto l_13;
l_14:;
}

}
#endif /* USE_ARGV */
#if 0
#include <signal.h>

static void
setup_signal_handlers(void)
{
	struct sigaction act;

	act.sa_handler = handle_signal;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
}
#endif

static void
setup_fonts(void)
{
#ifdef USE_XFT
#define FONTOPEN(f) XftFontOpenName(arwm.X.dpy, DefaultScreen(arwm.X.dpy), f)
#else /* !USE_XFT */
#define FONTOPEN(f) XLoadQueryFont(arwm.X.dpy, f)
#endif /* USE_XFT */

	arwm.X.font = opt.font ? FONTOPEN(opt.font) 
		: FONTOPEN(DEF_FONT);
	{
if (!(!arwm.X.font))
goto l_17;

		LOG_ERROR("couldn't find a font to use: "
			"try starting with -f fontname\n");l_17:;
}
}

void
arwm_grab_button(Window w, unsigned int mask, unsigned int button)
{
	{
l_18:

	{
#define GRAB(mod) XGrabButton(arwm.X.dpy, button, mask | mod, w, False,\
	ButtonMask, GrabModeAsync, GrabModeSync, None, None)
		GRAB(0);
		GRAB(LockMask);
		GRAB(Mod2Mask); /* Grab for ALT in client window */
	}if (0)
goto l_18;
l_19:;
}
;
}



static void
setup_event_listeners(const ubyte i)
{
	XSetWindowAttributes attr;

	/* set up root window attributes 
	   - same for each screen */
	attr.event_mask = ChildMask | EnterWindowMask
		| ColormapChangeMask | PropertyChangeMask;

	XChangeWindowAttributes(arwm.X.dpy, arwm.X.screens[i].root,
		CWEventMask, &attr);
}

static void
allocate_colors(const ubyte i)
{
	XColor dummy;

#define COLORALLOC(item)\
	XAllocNamedColor(arwm.X.dpy, DefaultColormap(arwm.X.dpy, i),\
		opt.color.item, &arwm.X.screens[i].item, &dummy);
	COLORALLOC(fg);
	COLORALLOC(bg);
	COLORALLOC(fc);
}

static void
setup_gc_parameters(XGCValues * gv, const ubyte i)
{
	allocate_colors(i);
	gv->foreground=arwm.X.screens[i].fg.pixel;
	gv->background=arwm.X.screens[i].bg.pixel;
	/* set up GC parameters - same for each screen */
	gv->function = GXinvert;
	gv->subwindow_mode = IncludeInferiors;
	gv->line_width = ARWM_BORDER_WIDTH;
#ifndef USE_XFT
	gv->font = arwm.X.font->fid;
#endif /* ! USE_XFT */
}

static void
setup_gc(const ubyte i)
{
	XGCValues gv;

	setup_gc_parameters(&gv, i);
	arwm.X.screens[i].gc=
		XCreateGC(arwm.X.dpy, arwm.X.screens[i].root,
		GCFunction | GCSubwindowMode | GCLineWidth
#ifndef USE_XFT
		| GCFont
#endif /* ! USE_XFT */
		, &gv);
}

static void
setup_each_client(int i, int j, Window * wins)
{
	XWindowAttributes winattr;

	{
if (!(!wins))
goto l_20;

		return;l_20:;
}
XGetWindowAttributes(arwm.X.dpy, wins[j], &winattr);
	{
if (!(!winattr.override_redirect
		&& winattr.map_state == IsViewable))
goto l_21;

		make_new_client(wins[j], &arwm.X.screens[i]);l_21:;
}
}

static void
setup_clients(const ubyte i)
{
	Window dw1, dw2, *wins;
	unsigned int j, nwins;

	XQueryTree(arwm.X.dpy, arwm.X.screens[i].root, &dw1, &dw2,
		&wins, &nwins);
	{
j = 0;l_22:
if (!( j < nwins))
goto l_24;
goto l_25;
l_23: j++;
goto l_22;
l_25:

		setup_each_client(i, j, wins);goto l_23;
l_24:;
}

	XFree(wins);
}

static void
setup_screen_elements(const ubyte i)
{
	arwm.X.screens[i].screen = i;
	arwm.X.screens[i].root = RootWindow(arwm.X.dpy, i);
	arwm.X.screens[i].vdesk = KEY_TO_VDESK(XK_1);
	arwm.X.screens[i].width=DisplayWidth(arwm.X.dpy, i);
	arwm.X.screens[i].height=DisplayHeight(arwm.X.dpy, i);
}

static void
setup_display_per_screen(int i)
{
	setup_screen_elements(i);
	setup_gc(i);
	setup_event_listeners(i);
	grab_keys_for_screen(&arwm.X.screens[i]);
	/* scan all the windows on this screen */
	setup_clients(i);
}

#ifdef USE_SHAPE
static void
setup_shape(void)
{
	int e_dummy;

	arwm.X.have_shape = XShapeQueryExtension(arwm.X.dpy, 
		&arwm.X.shape_event, &e_dummy);
}
#endif /* USE_SHAPE */

static void
setup_screens(void)
{
	/* now set up each screen in turn */
	arwm.X.num_screens = ScreenCount(arwm.X.dpy);
	arwm.X.screens = malloc(arwm.X.num_screens * sizeof(ScreenInfo));
	{
		/* used in scanning windows (XQueryTree) */
		ubyte i = arwm.X.num_screens;

		{
l_26:
if (!(i--))
goto l_27;

			setup_display_per_screen(i);goto l_26;
l_27:;
}

	}
}

static void
setup_display(void)
{
	const char * dpy_env = getenv("DISPLAY");
	{
if (!(!(arwm.X.dpy = XOpenDisplay(dpy_env?dpy_env:":0"))))
goto l_28;

		exit(1);l_28:;
}
XSetErrorHandler(handle_xerror);
	setup_fonts();
	arwm.X.cursor = XCreateFontCursor(arwm.X.dpy, XC_fleur);
#ifdef USE_SHAPE
	setup_shape();
#endif /* USE_SHAPE */
	setup_screens();
}

int
main(int argc
#ifndef USE_ARGV
__attribute__ ((unused))
#endif /* not USE_ARGV */
, char **argv
#ifndef USE_ARGV
__attribute__ ((unused))
#endif /* not USE_ARGV */
)
{
	initialize_ARWMEnvironment();
#ifdef USE_ARGV
	parse_command_line_args(argc, argv);
#endif /* USE_ARGV */
	setup_display();
#if 0
	setup_signal_handlers();
#endif 
	event_main_loop();

	return 1;
}
